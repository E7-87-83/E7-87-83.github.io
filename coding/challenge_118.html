<html>
<head>
  <meta charset="UTF-8">
  <meta name="description" content="CY's Puzzle Created on The Weekly Challenge #118 ‒ Pre-processing">
  <meta name="keywords" content="Perl, Chess, Programming, Algorithms">
  <meta name="author" content="Cheok-Yin Fung">  
  <link rel="styleSheet" href="../docs/main.css" type="text/css" media="all">
  <style>
    #wk118 tt {
      color:#E78783;
    }
    table td {
      border: 1px dotted black;
    }
    table th {
      border: 1px solid black;
    }

    h6 {
      font-size: medium;
    }
  </style>

<title>CY's Puzzle Created for The Weekly Challenge #118 ‒ Pre-processing </title>
</head>

<body>

<div class="heading">
<h1 align="right">The Weekly Challenge &dash; Perl and Raku</h1>
</div>

<div class="bar">
<ul>

  <li><a href="../index.html">Hello World</a></li>

  <li><a href="blog.html">Blog</a></li>

  <li><a href="../cv.html">Résumé</a></li>

  <li>Reserved</li>

  <li><a href="../links.html">Links</a></li>

</ul>
</div>

<div class="main">
  <h2>CY's Puzzle Created for The Weekly Challenge #118 &dash; Pre-processing</h2>

<p><i>If you want to challenge yourself on programming, especially on Perl and/or Raku,
go to <a href="https://perlweeklychallenge.org/" title="The Weekly Challenge - Perl & Raku">https://perlweeklychallenge.org</a>,
code the latest challenges, submit codes on-time (by GitHub or email).</i></p>

<p><strong>Do tell me, if I am wrong or you strongly oppose my statements! </strong></p>

<p><b><i>It's time for <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-118/" title="The Weekly Challenge #118">challenges
in Week #118</a> !</i></b></p>

<hr>

<h4>Task 2: Adventure of Knight</h4>


<div style="float:right; border: 1px dotted black; font-size:x-small;">
<image alt="" src="../docs/wiki_img/horse.png" style="float:right" />
<p>image info at bottom</p></div>

<p>TL;DR: I have demostrated the logic of getting the (length of) the shortest paths in a 4 &times; 4
board on the beginning POD section of <tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-118/cheok-yin-fung/perl/ch-2.pl" title="CY Fung's script for Week 118 Task 2">ch-2.pl</a></tt> .</p>

<h5><u>Puzzle Creation</u></h5>
<p>This week I am not only one of the participants, but also a coding puzzle creator!
I was quite excited about it.</p>

<p>Many people recognized that this task can be related to <a href="https://en.wikipedia.org/wiki/Knight%27s_tour" title="Wikipedia: Knight's tour">Knight's tour</a>. It is really
one of inspirations &dash; other important source of inspirations is "checkmate" exercises for chess
players.</p>

<p>Let's explain a bit on checkmate exercises. A checkmate exercise asks the chess
player moves one of its pieces to checkmate the opponent in a few steps
("a few", normally for newbie). Here is a Twitter account providing these puzzles: <a href="https://twitter.com/HourlyChess" title="Chess Puzzle Every Hour">@HourlyChess</a>.
Sometimes a form of related exercise
may be presented, it is "capture an important piece" exercise.
I found <a href="http://www.chesscuriosities.com/worksheets/worksheets" title="Chess Worksheets">
a nice collection</a>
by Mr David Petty. <font color="#CCCCCC">(Sorry for the site is commerical, as I could not find a non-commerical
site having these exercises.)</font></p>

<p><font color="#CCCCCC">Yes, having experience of practising chess gains advantage in this task.
Since there are tasks which people familiar with number theory have advantage,
I put this puzzle to submit. Isn't chess a popular game?</font></p>

<h5><u>Warm-Up</u></h5>

<h5>The Knight's Property</h5>
<blockquote><div border="1"><pre>N  3  2 
3     1
2  1  4
</pre></div></blockquote>

<p>The above small box often appears on my mind this week. It indicates number of steps of a knight
to move towards the other squares. In this 3 &times; 3 chessboard, the knight cannot
move to the diagonal immediate neighbour.</p>

<p>So imagine there are paddings that the knight can move to:</p>

<blockquote><div border="1"><pre>   ~  ~  ~
~  N  3  2 
~  3  2^ 1
~  2  1  4
</pre></div></blockquote>

<p>Here <tt>^</tt> temporarily indicates a value appears only when there are paddings.</p>

<h5>Move from A Square to Another Square</h5>

<p>The main purpose of this section is a discussion of how to get a shortest path to another square.</p>

<p>(I have thought of whether using a smaller distance table can solve the puzzle exactly. Like,
since 5 &times; 5 distance tables of two knights will ultimately overlap a
rectangle. It guarantees a solution, but may not be the <i>shortest</i> solution(s).)</p>

<blockquote><pre>my $dist_tbl = 
   [[0,3,2,3,2,3,4,5],
    [3,2,1,2,3,4,3,4],
    [2,1,4,3,2,3,4,5],
    [3,2,3,2,3,4,3,4],
    [2,3,2,3,4,3,4,5],
    [3,4,3,4,3,4,5,4],
    [4,3,4,3,4,5,4,5],
    [5,4,5,4,5,4,5,6]] ;</pre></blockquote>

<p><i>Caution for a special case:</i> <tt>[1][1] = 2</tt> only if neither departure point nor destination point is a corner;
<tt>[1][1] = 4</tt> if the starting point is a corner. My code uses a subroutine <tt>is_corner</tt>
to work-around it.</p>

<p><i>Caution:</i> Don't confuse <tt>$dist_tbl</tt> with the chessboard for this task! <font color="#CCCCCC">They are only related when the number of squares having treasure is 1 (and <tt>$dist_tbl-&gt;[1][1] = 4</tt> .</font></p>

<h5>How the Distance Table is Generated</h5>

<p>The pre-processing is in <tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-118/cheok-yin-fung/perl/pre-ch-2.pl" title="CY Fung's pre-processing script for Week 118 Task 2">pre-ch-2.pl</a></tt>.</p>

<p>The core of the pre-processing codes is only roughly 40 lines, let us see:</p>

<div><tt>
<b>my</b>&nbsp;<font color="#0000ff">$board</font>;<BR>
<BR>
<BR>
<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$k</font>&nbsp;(<font color="#00007f">1..63</font>)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#007f00">int</font>&nbsp;<font color="#0000ff">$k</font>&nbsp;/&nbsp;<font color="#00007f">8</font>][<font color="#0000ff">$k</font>&nbsp;%&nbsp;<font color="#00007f">8</font>]&nbsp;=&nbsp;<font color="#00007f">-1</font>;<BR>
}<BR>
<BR>
<font color="#0000ff">$board</font>-&gt;[0][0]&nbsp;=&nbsp;0;<BR>
<font color="#0000ff">$board</font>-&gt;[<font color="#00007f">1</font>][<font color="#00007f">1</font>]&nbsp;=&nbsp;<font color="#00007f">2</font>;<BR>
<BR>
<b>my</b>&nbsp;<font color="#0000ff">$total</font>&nbsp;=&nbsp;<font color="#00007f">62</font>;<BR>
<b>my</b>&nbsp;<font color="#0000ff">$t</font>&nbsp;=&nbsp;0;<BR>
<b>while</b>&nbsp;(<font color="#0000ff">$total</font>&nbsp;&gt;&nbsp;0)&nbsp;{<BR>
&nbsp;&nbsp;<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$i</font>&nbsp;(0.<font color="#00007f">.7</font>)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$j</font>&nbsp;(0.<font color="#00007f">.7</font>)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$i</font>][<font color="#0000ff">$j</font>]&nbsp;==&nbsp;<font color="#0000ff">$t</font>)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$a</font>&nbsp;(&nbsp;[<font color="#00007f">-2</font>,<font color="#00007f">-1</font>],&nbsp;&nbsp;[<font color="#00007f">-1</font>,<font color="#00007f">-2</font>],&nbsp;&nbsp;[<font color="#00007f">-2</font>,&nbsp;<font color="#00007f">1</font>],&nbsp;&nbsp;[&nbsp;<font color="#00007f">1</font>,<font color="#00007f">-2</font>],&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<font color="#00007f">-1</font>,&nbsp;<font color="#00007f">2</font>],&nbsp;&nbsp;[&nbsp;<font color="#00007f">2</font>,<font color="#00007f">-1</font>],&nbsp;&nbsp;[&nbsp;<font color="#00007f">1</font>,&nbsp;<font color="#00007f">2</font>],&nbsp;&nbsp;[&nbsp;<font color="#00007f">2</font>,&nbsp;<font color="#00007f">1</font>])<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$ai</font>&nbsp;=&nbsp;<font color="#0000ff">$i</font>+<font color="#0000ff">$a</font>-&gt;[0];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$aj</font>&nbsp;=&nbsp;<font color="#0000ff">$j</font>+<font color="#0000ff">$a</font>-&gt;[<font color="#00007f">1</font>];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(&nbsp;&nbsp;<font color="#0000ff">$ai</font>&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;<font color="#0000ff">$aj</font>&nbsp;&gt;=&nbsp;0&nbsp;&nbsp;&nbsp;<font color="#7f7f7f"><i>#no&nbsp;negative&nbsp;index</i></font><font color="#7f7f7f"><i><BR>
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;<font color="#007f00">defined</font>(<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$ai</font>][<font color="#0000ff">$aj</font>])&nbsp;<font color="#7f7f7f"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>#&nbsp;&nbsp;no&nbsp;running&nbsp;outside&nbsp;board</i></font><font color="#7f7f7f"><i><BR>
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$ai</font>][<font color="#0000ff">$aj</font>]&nbsp;==&nbsp;<font color="#00007f">-1</font>)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$ai</font>][<font color="#0000ff">$aj</font>]&nbsp;=&nbsp;<font color="#00007f">1</font>&nbsp;+&nbsp;<font color="#0000ff">$t</font>;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">$total</font>--;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<font color="#0000ff">$t</font>++;<BR>
}<BR>
<BR>
<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$i</font>&nbsp;(0.<font color="#00007f">.7</font>)&nbsp;{<BR>
&nbsp;&nbsp;<b>for</b>&nbsp;<b>my</b>&nbsp;<font color="#0000ff">$j</font>&nbsp;(0.<font color="#00007f">.7</font>)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#007f00">print</font>&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$i</font>][<font color="#0000ff">$j</font>],&nbsp;<font color="#ffa500">"</font><font color="#ff0000">&nbsp;</font><font color="#ffa500">"</font>&nbsp;<b>if</b>&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$i</font>][<font color="#0000ff">$j</font>]&nbsp;&gt;=&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#007f00">print</font>&nbsp;<font color="#ffa500">"</font><font color="#ff0000">*</font><font color="#ffa500">"</font>,&nbsp;<font color="#ffa500">"</font><font color="#ff0000">&nbsp;</font><font color="#ffa500">"</font>&nbsp;<b>if</b>&nbsp;<font color="#0000ff">$board</font>-&gt;[<font color="#0000ff">$i</font>][<font color="#0000ff">$j</font>]&nbsp;==&nbsp;<font color="#00007f">-1</font>;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;<font color="#007f00">print</font>&nbsp;<font color="#ffa500">"</font><font color="#ff00ff">\n</font><font color="#ffa500">"</font>;<BR>
}<BR>
</tt></div>

<p>Yup, there are so many nested blocks hence 4-space-indentation has to be replaced by
2-space-indentation.</p>

<p>When it comes to squares reachable within 3 steps, <tt>$board</tt> in <tt>pre-ch-2.pl</tt>,
corresponds to <tt>$dist_tbl</tt> in <tt>ch-2.pl</tt>, is like this:</p>

<blockquote><pre><tt>0 3 2 3 2 3 * * 
3 2 1 2 3 * 3 * 
2 1 * 3 2 3 * * 
3 2 3 2 3 * 3 * 
2 3 2 3 * 3 * * 
3 * 3 * 3 * * * 
* 3 * 3 * * * * 
* * * * * * * * </tt></pre></blockquote>

<p>By luck(?), the number of steps to reach every square is consecutive from 0 to 6…
This part may have to be “aggressively” modified if the chessboard is irregular.</p>

<div><font color="#999999"><u>Story on logical errors:</u>

<p>The original I coded</p>

<blockquote><tt>if (  defined($board->[$ai][$aj])<br> 
       &nbsp;&nbsp;&nbsp;&nbsp;&& $board->[$ai][$aj] == -1)</tt></blockquote>

<p>The code crashed. After I discovered it was caused by the
negative index for array feature,
I changed it into</p>

<blockquote><tt>if (  $ai >= 0 && $aj >= 0 <br> 
       &nbsp;&nbsp;&nbsp;&nbsp;&& $board->[$ai][$aj] == -1)</tt></blockquote>

<p>It was still "featured" with bugs &dash; luckily, the interpreter told that the
bug was related to uninitialized values.</p>

<p>As you can see the final version above, I omit it here.</p>

<p>(Much earlier: I created a <tt>$visited</tt> variable for saving whether
a square is traversed and whether a square computes its possible next step.)
</font></p></div>

<h5><u>Main Dish</u></h5>

<p>Since a large part of problem-solving is done by <tt>pre-ch-2.pl</tt>,
the main code consists of only 6 subroutines:</p>

<blockquote><pre>dist_fun
compare_mini
alphanumeric
binumeric_position
is_corner
expand</pre></blockquote>
<ul id="wk118">
<li>(Supportive:) <tt>&amp;alphanumeric</tt> and <tt>&amp;binumeric_position</tt> interchange the
notation of a position. For example, <code>a6</code>→<code>[0,2]</code>, <code>b2</code>→<code>[1,6]</code>, <code>d4</code>→<code>[3,4]</code>, etc.. </li>
<li><tt>&amp;expand</tt> will return a knight's path with a pre-set number of steps between two positions.
Its internal is very similar to <tt>pre-ch-2.pl</tt>.</li>
<li><tt>&amp;dist_fun</tt> uses <tt>$dist_tbl</tt> as a reference and handle the corner case.
It returns the minimum number of steps between two position.</li>
<li><tt>&amp;is_corner</tt> is a supportive subroutine to <tt>&amp;dist_fun</tt>. It returns whether a position is one of the chessboard four corners.</li>
<li><tt>&amp;compare_mini</tt> compares a path with information of positions having treasure, sees whether the order of traversing the positions with treasure is a candidate for the shortest path.</li>
</ul>

The code is written in the procedural style:

<div style="color:white; background-color:black; padding-left: 5px">
<pre><font color="#FCE94F">use strict</font>;
<font color="#FCE94F">use warnings</font>;
<font color="#FCE94F">use</font> <a href="https://metacpan.org/pod/Algorithm::Combinatorics" title="CPAN module - Algorithm::Combinatorics">Algorithm::Combinatorics</a> <font color="#AD7FA8">qw/permutations/</font>;

<font color="#FCE94F">die</font> <font color="#AD7FA8">&quot;Give me positions with treasure!</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font> <font color="#FCE94F">unless</font> <font color="#34E2E2"><b>$ARGV[</b></font><font color="#AD7FA8">0</font><font color="#34E2E2"><b>]</b></font>;
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@treasures</b></font> = <font color="#FCE94F">map</font> <font color="#FCE94F">{</font> binumeric_position(<font color="#34E2E2"><b>$_</b></font>) <font color="#FCE94F">}</font> <font color="#34E2E2"><b>@ARGV</b></font>;

<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$min_path_length</b></font> = <font color="#AD7FA8">1000</font>;
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@min_paths</b></font> = ();



<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$dist_tbl</b></font> = <font color="#34E2E2">#[[],[],...];</font>


<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$iter</b></font> = permutations( \<font color="#34E2E2"><b>@treasures</b></font> );
<font color="#FCE94F">while</font> (<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$p</b></font> = <font color="#34E2E2"><b>$iter-&gt;next</b></font>) {
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$path_length</b></font> = dist_fun([<font color="#AD7FA8">0</font>,<font color="#AD7FA8">0</font>], <font color="#34E2E2"><b>$p-&gt;[</b></font><font color="#AD7FA8">0</font><font color="#34E2E2"><b>]</b></font>);
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$i</b></font> = <font color="#AD7FA8">0</font>;
    <font color="#FCE94F">while</font> (<font color="#34E2E2"><b>$i</b></font> &lt; <font color="#34E2E2"><b>$p-&gt;$#*</b></font>) {
        <font color="#34E2E2"><b>$path_length</b></font> += dist_fun(<font color="#34E2E2"><b>$p-&gt;[$i]</b></font>, <font color="#34E2E2"><b>$p-&gt;[$i</b></font>+<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>);
        <font color="#34E2E2"><b>$i</b></font>++;
    }
    compare_mini(<font color="#34E2E2"><b>$path_length</b></font>, <font color="#34E2E2"><b>$p</b></font>);
}


<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$total</b></font> = <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@min_paths</b></font>;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;The number of minimum path(s) is more than or equal to </font><font color="#34E2E2"><b>$total</b></font><font color="#AD7FA8">.</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;Path length: </font><font color="#34E2E2"><b>$min_path_length</b></font><font color="#AD7FA8">.</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>;
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>$gd</b></font> = <font color="#FCE94F">int</font>(<font color="#FCE94F">rand</font>(<font color="#34E2E2"><b>$total</b></font>));
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;Treasure spots shown only: &quot;</font>;
<font color="#FCE94F">print</font> <font color="#FCE94F">join</font> <font color="#AD7FA8">&quot;=&gt;&quot;</font>, <font color="#FCE94F">map</font> <font color="#FCE94F">{</font>alphanumeric(<font color="#34E2E2"><b>$_</b></font>)<font color="#FCE94F">}</font> <font color="#34E2E2"><b>$min_paths[$gd]-&gt;@*</b></font>;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;</font><font color="#FFD7D7">\n\n</font><font color="#AD7FA8">&quot;</font>;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;A full path:</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;   &quot;</font>, <font color="#FCE94F">join</font> <font color="#AD7FA8">&quot;-&gt;&quot;</font>, <font color="#FCE94F">map</font> <font color="#FCE94F">{</font>alphanumeric(<font color="#34E2E2"><b>$_</b></font>)<font color="#FCE94F">}</font>
                expand([<font color="#AD7FA8">0</font>,<font color="#AD7FA8">0</font>], <font color="#34E2E2"><b>$min_paths[$gd]-&gt;[</b></font><font color="#AD7FA8">0</font><font color="#34E2E2"><b>]</b></font>)-&gt;@*;
<font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>;
<font color="#FCE94F">for</font> <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$s</b></font> (<font color="#AD7FA8">0.</font>.<font color="#34E2E2"><b>$#treasures</b></font>-<font color="#AD7FA8">1</font>) {
    <font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;=&gt; &quot;</font>;
    <font color="#FCE94F">print</font> <font color="#FCE94F">join</font> <font color="#AD7FA8">&quot;-&gt;&quot;</font>, <font color="#FCE94F">map</font> <font color="#FCE94F">{</font>alphanumeric(<font color="#34E2E2"><b>$_</b></font>)<font color="#FCE94F">}</font>
                expand(<font color="#34E2E2"><b>$min_paths[$gd]-&gt;[$s]</b></font>, <font color="#34E2E2"><b>$min_paths[$gd]-&gt;[$s</b></font>+<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>)-&gt;@*;
    <font color="#FCE94F">print</font> <font color="#AD7FA8">&quot;</font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>;
}

</pre>
</div>

The given condition in the task statement has only one permutation of visiting the spots is minimum; see the output of the program:
<blockquote><pre>$ time perl ch-2.pl a2 b1 b2 b3 c4 e6
The number of minimum path(s) is more than or equal to 1.
Path length: 11.
Treasure spots shown only: e6=>b3=>a2=>b1=>c4=>b2

A full path:
   a8->c7->e6
=> e6->c5->b3
=> b3->c1->a2
=> a2->c3->b1
=> b1->a3->c4
=> c4->b2

real	0m0.066s
user	0m0.028s
sys	0m0.008s</pre></blockquote>

<h5><u>Performance and Extensibility</u></h5>

I have randomly generated some chessboard positions for testing.

<p>Case I: (9 spots)</p>
<blockquote><pre>$ time perl ch-2.pl h3 d7 g7 h4 b4 c2 g2 b6 d4
The number of minimum path(s) is more than or equal to 2.
Path length: 14.
Treasure spots shown only: b6=>d7=>b4=>c2=>d4=>g7=>h4=>g2=>h3

A full path:
   a8->b6
=> b6->d7
=> d7->b8->a6->b4
=> b4->c2
=> c2->d4
=> d4->e6->g7
=> g7->f5->h4
=> h4->g2
=> g2->f4->h3

real	0m4.263s
user	0m4.257s
sys	0m0.004s
</pre></blockquote>

<p>Case II: (10 spots)</p>
<blockquote><pre>$ time perl ch-2.pl h3 d7 g7 h4 b4 c2 g2 b6 d4 d1
The number of minimum path(s) is more than or equal to 4.
Path length: 16.
Treasure spots shown only: d7=>b6=>b4=>c2=>d4=>g7=>h4=>g2=>d1=>h3

A full path:
   a8->b6->d7
=> d7->b6
=> b6->d5->b4
=> b4->c2
=> c2->d4
=> d4->e6->g7
=> g7->f5->h4
=> h4->g2
=> g2->e3->d1
=> d1->f2->h3

real	0m46.254s
user	0m46.223s
sys	0m0.000s
</pre></blockquote>

<p>Case III: (12 spots)</p>
<blockquote><pre>
$ time perl ch-2.pl h3 d7 g7 h4 b4 c2 g2 b6 d4 d1 c5 e4 
The number of minimum path(s) is more than or equal to 2.
Path length: 17.
Treasure spots shown only: b6=>d7=>c5=>e4=>d1=>h3=>g2=>h4=>g7=>d4=>c2=>b4

A full path:
   a8->b6
=> b6->d7
=> d7->c5
=> c5->e4
=> e4->c3->d1
=> d1->f2->h3
=> h3->f4->g2
=> g2->h4
=> h4->f5->g7
=> g7->e6->d4
=> d4->c2
=> c2->b4

real	130m8.447s
user	129m54.621s
sys	0m1.240s
</pre></blockquote>

<table style="text-align:center">
  <tr><th>Case</th><th>Number of Spots</th><th>Time</th><th><small>Number of Permutations</small></th></tr>
  <tr><td><small>Task specific</small></td><td>6</td><td>0.066 sec</td><td>720</td></tr>
  <tr><td>I</td><td>9</td><td>4.263 sec</td><td>362,880</td></tr>
  <tr><td>II</td><td>10</td><td>46.254 sec</td><td>3,628,800</td></tr>
  <tr><td>III</td><td>12</td><td>130 min 8.447 sec</td><td>479,001,600</td></tr>
</table>

<p>12! = 10! &times; 132 = 479,001,600; the time of Case III is 130 min
and the time of Case II is approximately 75% of 1 min;
not surprisingly, the implementation is <tt>ϴ(n<sup>n+0.5</sup> exp(1/(12*n)) )</tt> [<a href="https://en.wikipedia.org/wiki/Factorial#Rate_of_growth_and_approximations_for_large_n" title="Wikipedia: Factorial">ref</a>]. </p>



<h5><u>Farewell Messages</u></h5>

<h6>Insight from Others</h6>
<p>Peeking at <a href="https://github.com/manwar/perlweeklychallenge-club/" title="manwar/perlweeklychallenge-club: Knowledge base for The Weekly Challenge club">the team's GitHub</a>, I found a submission using <tt><a href="https://metacpan.org/pod/Algorithm::Permute" title="CPAN module - Algorithm::Permute">Algorithm::Permute</a></tt> and <tt><a href="https://metacpan.org/pod/Memoize"  title="CPAN module - Memoize">Memoize</a></tt>, within 85 lines of code, brought a faster solution for the task specific data set! Of course, I quickly kept my arrogance: it is approx. 10% slower than my code with respect to 9 spots and spent 1 min on 10 spots.</p>

<p>Differences of the two permutation algorithms seems unlikely the source of power burst.
What makes his faster than mine for those 6 spots with treasure!?</p>

<p>It is <tt><strong>Memoize</strong></tt>. RJT has recommended the free book “<a href="https://hop.perl.plover.com" title="Higher-Order Perl">Higher-Order Perl</a>”(published in 2005) to me long time ago and the book has a whole chapter on “Caching and Memoization”. Ooops. I quickly put <tt>use Memoize;</tt>
and <tt>memoize("expand");</tt> into my code, and mine runs faster than his now
(... not wasting the effort of extra dozens of codes on pre-processing) now.</p>

<h6>mathematics of Knight's tour</h6>
<p>Using <a href="https://en.wikipedia.org/wiki/Knight%27s_tour" title="Wikipedia: Knight's tour">Knight's tour</a> seems not a promising approach for a reasonably short path.
But it solves the challenge, anyway. :)</p>

<p>Here is just a short summary compiled from the Wikipedia page
<a href="https://en.wikipedia.org/wiki/Knight's_graph" title="Wikipedia: Knight's graph">Knight's (tour) graph</a>:
It has 64 vertices (it's kind of obvious, arrr) and 168 edges. How fast will we get if we 
enter the data to some mathematicians' softwares (the most famous one must be Mathematica, and if you prefer FOSS,
I could name <a href="https://maxima.sourceforge.io" title="Maxima, a Computer Algebra System">Maxima</a> and
<a href="http://pari.math.u-bordeaux.fr" title="PARI/GP Development Headquarters">PARI/GP</a>.)?</p>


<p>It could be a small project on getting familiar with the computer algebra system.
(Sorry that I am not experienced enough for trying it on Maxima as a dumb math enthusiast.)</p>

<h6>a shortest path, or a reasonably short path</h6>
<p>As the puzzle creator, what I dream to see is a script which is
very creative or compact but providing reasonably short paths.</p>

<p>For a "shortest" path solution, are there any ways besides listing the permutations?</p>

<p>As a puzzle creator, maybe I should have better or more detailed wordings for a bonus next time.</p>

<p>Stay alert and healthy! □</p>

<hr>

<div><h4>Update on 27th June</h4> <br>

Soon after a cry on Twitter, E. Choroba
 invited us to take a look on his <a href="https://www.geeksforgeeks.org/a-search-algorithm/">A* search</a> solution. It does not list out
all permutations but find a shortest
 path. And it is much faster &dash; for cases on 6 to 12 spots, it does
its responsibility within 10 seconds
It finishes a 16-spot case in 4 minute and 9.199 second. Bravo.</div>

<hr>

<p>The image of the knight (horse head) is from Wikimedia Commons; the image is
released under <a href="https://www.gnu.org/licenses/lgpl-3.0.html" title="LGPL">GNU Lesser General Public License</a>.
Its author is Maurizio Monge. See the
<a href="https://commons.wikimedia.org/wiki/File:Chess_Maurizio_Monge_Spatial_bn.svg"
title="Wikimedia Commons: Chess_Maurizio_Monge_Spatial_bn.svg">file details</a>.</p>

<p><i>link for full codes: <tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-118/cheok-yin-fung/perl/pre-ch-2.pl" title="pre-ch-2.pl from Cheok-Yin Fung">pre-ch-2.pl</a></tt> (pre-processing), <tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-118/cheok-yin-fung/perl/ch-2.pl" title="ch-2.pl from Cheok-Yin Fung">ch-2.pl</a></tt></i></p>

<p><i>link to my blogpost for <a href="challenge_118t1.html" title="CY's Take on The Weekly Challenge #118 Task 1 ‐ Being a random_sort_char("Begin")-ner">Task 1 "Binary Palindrome" #(Being a random_sort_char("Begin")-ner)</a></i></p>

<hr>
<p>Contact on twitter: <a href="https://twitter.com/e7_87">@e7_87</a>.</p>

<p>Created Date: 26th June, 2021; last updated: 27th June, 12:10 HKT (27th June 04:10 UTC).

<p>[27th Jun 12:10 HKT] A major update and apology on the bound of <tt>n!</tt>.</p>

<div>[26th Jun 22:00 HKT] A major update: It must be unfair to E. Choroba if I do not share it:
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-118/e-choroba/perl/ch-2.pl" title="ch-2.pl from E. Choroba">E. Choroba's solution</a>, employing the object-oriented paradigm, using the <a href="https://www.geeksforgeeks.org/a-search-algorithm/">A* search Algorithm</a>, finishes the 12-spot case within 8~9 seconds on my machine! I have to be more hard-working.

<pre>
$ cat data
  a b c d e f g h
8 N * * * * * * * 8
7 * * * x * * x * 7
6 * x * * * * * * 6
5 * * x * * * * * 5
4 * x * x x * * x 4
3 * * * * * * * x 3
2 * * x * * * x * 2
1 * * * x * * * * 1
  a b c d e f g h


$ time perl choroba-ch-2.pl < data
Steps: 154299
17: a8, b6, d7, c5, e4, g5, h3, f2, d1, e3, g2, h4, f5, g7, f5, d4, c2, b4

real	0m8.672s
user	0m8.636s
sys	0m0.032s

$ time perl choroba-ch-2.pl < data
Steps: 154299
17: a8, b6, d7, c5, e4, g5, h3, f2, d1, e3, g2, h4, f5, g7, f5, d4, c2, b4

real	0m8.784s
user	0m8.744s
sys	0m0.036s

$ time perl choroba-ch-2.pl < data
Steps: 154299
17: a8, b6, d7, c5, e4, g5, h3, f2, d1, e3, g2, h4, f5, g7, f5, d4, c2, b4

real	0m8.779s
user	0m8.735s
sys	0m0.040s
</pre>

</div>

<p>[26th Jun 20:10 HKT] A major update and apology: The paths we are seeking are usually not <a href="https://en.wikipedia.org/wiki/Hamiltonian_path" title="Wikipedia: Hamiltonian path">Hamiltonian paths</a>.</p>

</body>

</html>


