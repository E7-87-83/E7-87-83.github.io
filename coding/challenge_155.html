<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="description" content="CY's Take on The Weekly Challenge #155">
  <meta name="keywords" content="Perl, number theory, linear recurrence">
  <meta name="author" content="Cheok-Yin Fung">  
  <link rel="styleSheet" href="../docs/main.css" type="text/css" media="(min-device-width: 769px)">
  <link rel="stylesheet" href="../docs/mobile.css" type="text/css" media="only screen and (max-device-width: 768px)">

  <style>
    body {background-color:#1E90FF} 
    div.bar li {background-color:yellow}
  </style>
  <title>CY's Take on The Weekly Challenge #155 </title>
</head>

<body>

<div class="heading">
<h1 align="right">The Weekly Challenge &dash; Perl and Raku</h1>
</div>

<div class="bar">
<ul> 

  <li><a href="../index.html">Hello World</a></li>

  <li><a href="blog.html">Blog</a></li>

  <li><a href="../cv.html">Résumé</a></li>

  <li><a href="../prod.html">Production</a></li>

  <li><a href="../links.html">Links</a></li>

</ul>
</div>

<div class="main"> 
  <h2>CY's Take on The Weekly Challenge #155</h2>

<p><i>If you want to challenge yourself on programming, especially on Perl and/or Raku,
go to <a href="https://theweeklychallenge.org/" title="The Weekly Challenge - Perl & Raku">https://theweeklychallenge.org</a>,
code the latest challenges, submit codes on-time (by GitHub or email).</i></p>

<p><strong>Do tell me, if I am wrong or you strongly oppose my statements! </strong></p>

<p><b><i>It's time for <a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-155/" title="The Weekly Challenge #155">challenges
in Week #155</a> !</i></b></p>

<hr>



<h4>Task 1: Fortunate Numbers</h4>

<blockquote>(From Wikipedia) One of unsolved problems in mathematics:<br>
Fortune's conjecture: Are any Fortunate numbers composite?</blockquote>

<p>
I have never thought that things like primorial can go with such an interesting and natural conjecture.</p>

<p>Looking at the wikipedia page linked from the task statement, we know that there
are TWO sequences of Fortunate numbers:</p> 

<p>The first one is <code>a<sub>1</sub></code>(<i>n</i>)
is the smallest integer <i>m</i> so that <i>m</i> + primorial(<i>n</i>) is prime.</p>

<p>The second one is <code>sort {$a&lt;=&gt;$b}
<a href="https://metacpan.org/pod/List::Util#uniqint">uniqint</a> a<sub>1</sub></code>
(or equivalently, <code>uniqint sort {$a&lt;=&gt;$b} a<sub>1</sub></code> <sup><a href="note1">[1]</a></sup>). </p> 

<p>The task requires us to generate the second sequence.</p>

<p>&nbsp;</p>

<p>A concern is, <code>a<sub>1</sub></code>(<i>x</i>) can be smaller than <code>a<sub>1</sub></code>(<i>y</i>) when <i>x</i> &gt;
<i>y</i>. So how do we know when to stop generating terms of 
<code>a<sub>1</sub></code>?
</p>

<p>Keep reading on the Wikipedia gives us a hint: "The Fortunate number for primorial(<i>n</i>)
is always above <i>p</i><sub><i>n</i></sub>."</p>

<p>So after we get a length-<code>$N</code> list of non-duplicate values of <code>a<sub>1</sub></code>
we grasp its largest element <code>$E</code>, and check whether there are Fortunate numbers smaller than <code>$E</code>.
The check will be stopped when we reach <i>j</i>, where <i>j</i>
is determined from the inequality
<i>p</i><sub><i>j</i></sub> &le; <code>$E</code> &lt; <i>p</i><sub><i>j</i>+1</sub>
.</p>

<p>&nbsp;</p>
<p>The worry has been cleared and we should start to code:</p>

<p>The first part, to generate <code>a<sub>1</sub></code> up to a certain "large-enough" value:</p>

<div class="code_vim_hl">
<pre>
# first part

{
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$k</b></font> = <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@primorials</b></font> - <font color="#AD7FA8">1</font>;
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$tmp_int</b></font> = <font color="#34E2E2"><b>$primes[$k]</b></font>;
    <font color="#FCE94F">do</font> {
        <font color="#34E2E2"><b>$tmp_int</b></font>++;
    } <font color="#FCE94F">while</font> (!is_prime( <font color="#34E2E2"><b>$primorials[</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font> + <font color="#34E2E2"><b>$tmp_int</b></font> ));
    <font color="#FCE94F">push</font> <font color="#34E2E2"><b>@fort_unsort</b></font>, <font color="#34E2E2"><b>$tmp_int</b></font>;
    iter_primorial();    <i><font color="grey"># generate the next primorial</font></i>
    <font color="#34E2E2"><b>@fort_sorted</b></font> = uniqint <font color="#FCE94F">sort</font> <font color="#FCE94F">{</font><font color="#34E2E2"><b>$a</b></font>&lt;=&gt;<font color="#34E2E2"><b>$b</b></font><font color="#FCE94F">}</font> <font color="#34E2E2"><b>@fort_unsort</b></font>;
}
</pre>
</div>

<p>Terms in <code>@primorials</code> grow fast and I set them to be <code>Math::BigInt</code> objects. This is the reason that I generate it one-by-one &dash; avoid eating up memory.</p>

<p>The second part, to check whether there are any small Fortunate numbers
not yet included in <code>@fort_unsort</code>:</p> 

<div class="code_vim_hl">

<pre>
# second part
{
    # ... 
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$k</b></font> = <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@primorials</b></font> - <font color="#AD7FA8">1</font>;
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$tmp_int</b></font> = <font color="#34E2E2"><b>$primes[$k]</b></font>;
    <font color="#FCE94F">do</font> {
        <font color="#34E2E2"><b>$tmp_int</b></font>++;
    } <font color="#FCE94F">while</font> (!is_prime( <font color="#34E2E2"><b>$primorials[</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font> + <font color="#34E2E2"><b>$tmp_int</b></font> ));
    <font color="#FCE94F">push</font> <font color="#34E2E2"><b>@fort_unsort</b></font>, <font color="#34E2E2"><b>$tmp_int</b></font>;
    <font color="#34E2E2"><b>@fort_sorted</b></font> = uniqint <font color="#FCE94F">sort</font> <font color="#FCE94F">{</font><font color="#34E2E2"><b>$a</b></font>&lt;=&gt;<font color="#34E2E2"><b>$b</b></font><font color="#FCE94F">}</font> <font color="#34E2E2"><b>@fort_unsort</b></font>;
}

</pre>

</div>

<p>I try to keep the size of <code>@primes</code> and <code>@primorials</code> same.
And at certain moment I felt the name of <code>@primes</code> confusing, because it is not a full list
of primes. Then I changed it into <code>@ch_primes</code>.</p>

<p>Here I revealed the loop conditional for the second part:</p>

<div class="code_vim_hl">

<pre><font color="#FCE94F">while</font> ( <font color="#34E2E2"><b>$fort_sorted[$N</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font> &gt; <font color="#34E2E2"><b>$ch_primes[</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>)</pre>

</div>

<p>The loop conditional for the first part, actually, can be quite arbitary. Each time the block runs, <code>@fort_sorted</code> is either increased by 1 or remain the same. One may casually use 
<code>while (scalar @fort_sorted != 2*$N )</code>
or
<code>while (scalar @fort_sorted &lt; 2*$N )</code>
, and s/he could even skip the second part ... IF LUCKY ENOUGH?
</p>

<p>To be a careful programmer, I use</p>

<div class="code_vim_hl">
<pre><font color="#FCE94F">while</font> (<font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@fort_sorted</b></font> &lt; <font color="#34E2E2"><b>$N</b></font>) {
</pre>
</div>

<p>Since the first part and the second part look so similar, I combine them by an short-circuit or, here is the code:</p>

<div class="code_vim_hl">
<pre><font color="#FCE94F">my</font> <font color="#34E2E2"><b>$N</b></font> = <font color="#34E2E2"><b>$ARGV[</b></font><font color="#AD7FA8">0</font><font color="#34E2E2"><b>]</b></font> || <font color="#AD7FA8">8</font>;

<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@ch_primes</b></font> = (<font color="#AD7FA8">2</font>);
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@primorials</b></font> = ( Math::BigInt-&gt;new(<font color="#AD7FA8">2</font>) );
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@fort_unsort</b></font> = ();
<font color="#FCE94F">my</font> <font color="#34E2E2"><b>@fort_sorted</b></font> = ();



<font color="#FCE94F">while</font> ( (<font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@fort_sorted</b></font> &lt; <font color="#34E2E2"><b>$N</b></font>)
               ||
        (<font color="#FCE94F">defined</font>(<font color="#34E2E2"><b>$fort_sorted[$N</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>) &amp;&amp; <font color="#34E2E2"><b>$fort_sorted[$N</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font> &gt; <font color="#34E2E2"><b>$ch_primes[</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>)
) {
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$k</b></font> = <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@fort_unsort</b></font>;
    <font color="#FCE94F">my</font> <font color="#34E2E2"><b>$tmp_int</b></font> = <font color="#34E2E2"><b>$ch_primes[$k]</b></font>;
    <font color="#FCE94F">do</font> {
        <font color="#34E2E2"><b>$tmp_int</b></font>++;
    } <font color="#FCE94F">while</font> (!is_prime( <font color="#34E2E2"><b>$primorials[$k]</b></font> + <font color="#34E2E2"><b>$tmp_int</b></font> ));
    <font color="#FCE94F">push</font> <font color="#34E2E2"><b>@fort_unsort</b></font>, <font color="#34E2E2"><b>$tmp_int</b></font>;
    iter_primorial() <font color="#FCE94F">while</font> <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@primorials</b></font> &lt;= <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@fort_unsort</b></font>;
    iter_prime() <font color="#FCE94F">while</font> <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@ch_primes</b></font> &lt;= <font color="#FCE94F">scalar</font> <font color="#34E2E2"><b>@primorials</b></font>;
    <font color="#34E2E2"><b>@fort_sorted</b></font> = uniqint <font color="#FCE94F">sort</font> <font color="#FCE94F">{</font><font color="#34E2E2"><b>$a</b></font>&lt;=&gt;<font color="#34E2E2"><b>$b</b></font><font color="#FCE94F">}</font> <font color="#34E2E2"><b>@fort_unsort</b></font>;
}

<font color="#FCE94F">say</font> <font color="#AD7FA8">&quot;Answer: </font><font color="#FFD7D7">\n</font><font color="#AD7FA8">&quot;</font>, <font color="#FCE94F">join</font> <font color="#AD7FA8">&quot;, &quot;</font>, <font color="#34E2E2"><b>@fort_sorted[</b></font><font color="#AD7FA8">0.</font>.<font color="#34E2E2"><b>$N</b></font>-<font color="#AD7FA8">1</font><font color="#34E2E2"><b>]</b></font>;
</pre>

</div>

<p>Is the heuristic <code>while (scalar @fort_sorted &lt; 2*$N )</code>
good? Let add a line <code>say scalar @fort_unsort;</code> and see:
</p>

<table border="1" style="text-align:center">
<tr>  <th><code>$N</code></th>  <th><code>scalar @fort_unsort</code></th>  </tr>
<tr>  <td>8</td>  <td>10</td>  </tr>
<tr>  <td>16</td>  <td>24</td>  </tr>
<tr>  <td>38</td>  <td>63</td>  </tr>
<tr>  <td>50</td>  <td>84</td>  </tr>
<tr>  <td>101</td>  <td>183</td>  </tr>
<tr>  <td>150</td>  <td>272</td>  </tr>
</table>

<p>An anecdote: we never assume the Fortunate conjecture true all along the code process, though, 
it's quite cool.</p>

<h4>Task 2: Pisano Period</h4>

<p>As usual I try to generalize. This time I generalize it into arbitary length of "order" of linear recurrence.</p>

<div class="code_vim_hl"><pre><a href="https://oeis.org/wiki/Index_to_OEIS:_Section_Rec">https://oeis.org/wiki/Index_to_OEIS:_Section_Rec</a>

ch-2.pl $N 2   1 1       0 1   # Fibonacci numbers

ch-2.pl $N 2   1 1       2 1   # Lucas numbers    #OEIS:A000032

ch-2.pl $N 2   1 2       0 1   # Pell numbers     #OEIS:A000032

ch-2.pl $N 3   1 1 0  1 1 1 # Padovan numbers     #OEIS:A000931

ch-2.pl $N 3   1 1 1  0 0 1 # Tribonacci numbers  #OEIS:A000073

ch-2.pl $N 3   1 0 1  1 1 1 # Narayana's cows sequence #A000930

ch-2.pl $N 6  -1 -1 0 -1 2 1   1 2 2 4 5 9             #A001224

ch-2.pl $N 6   1 -1 -1 0 1 1   1 1 2 3 4 5             #A001399

</pre></div>

<p><big><big>TO BE WRITTEN</big></big></p>

<!--<p>Stay alert and healthy! □</p>-->

<hr>

<p>Notes:</p>

<p>1: <a name="note1"></a>From my testing upto the highest member of the sequence is 1103, the performance between the different order of occurring of the two array operations seems to be very close).</p>

<p><small>Except from images and codes from other personnels, the content of this blogpost is released under a copyleft spirit. One may share (full or partial) content of this blogpost on other platform if you share it under the free and open content spirit.</small></p>

<p><i>link for CY's full codes: <tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-155/cheok-yin-fung/perl/ch-1.pl" title="ch-1.pl from Cheok-Yin Fung">ch-1.pl</a></tt>, 
<tt><a href="https://github.com/E7-87-83/perlweeklychallenge-club/blob/newt/challenge-155/cheok-yin-fung/perl/ch-2.pl" title="ch-2.pl from Cheok-Yin Fung">ch-2.pl</a></tt>
</i>
</p>
<hr>
<p>Contact on twitter: <a href="https://twitter.com/e7_87">@e7_87</a>.</p>
<p>Discuss via GitHub issues: <a href="https://github.com/E7-87-83/E7-87-83.github.io/issues">here</a>. </p>
<p>Email: fungcheokyin at gmail.com</p>
<p>Created Date: 10th March, 2022.</p>

</body>

</html>
